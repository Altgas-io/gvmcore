
#define MAIN_TYPE int256
#define MAIN_TYPE_SIZE 256
#define EVM_ADDR_TYPE int160
#define EVM_BALANCE_TYPE int32

#define DATA_SIZE 1024
#define STORAGE_SIZE 256
#define LOG_AREA_SIZE 1024
#define INPUT_DATA_SIZE 1024
#define STACK_SIZE  2048

#include "gascost.h"

Device EVM
{
  //stack pointer
  Var int32 sp, "sp";
  // program couter
  Reg int32 pc,"pc";
  Var int1  is_pc_within_inst;
  
  // account specific regs
  Reg EVM_ADDR_TYPE     cur_addr,"cur_addr";
  Reg EVM_ADDR_TYPE     caller_addr, "caller_addr";  
  Reg EVM_ADDR_TYPE     origin_addr, "origin_addr";
 
  Reg EVM_BALANCE_TYPE  gas_price, "gas_price";  
  Reg EVM_BALANCE_TYPE  gas_available, "gas_available";
  
  Reg MAIN_TYPE  code_size,"code_size";
  Reg MAIN_TYPE  ext_code_size,"ext_code_size";
  Reg MAIN_TYPE  inp_data_size,"inp_data_size"; 
  // size of active memory 
  Reg int32 mem_size; // active memory size (filled outside of simulation)
  // current block

  MemSpace prog_bus, 32, 32;
  // memory access  (256 size data bus)
  /*MemSpace data_bus, 32, MAIN_TYPE_SIZE;
  MemSpace storage_bus, 32, MAIN_TYPE_SIZE;
  MemSpace log_bus, 32, MAIN_TYPE_SIZE;
  MemSpace input_data, 32,MAIN_TYPE_SIZE;
  */
  Reg int8 data_bus[DATA_SIZE];
  Reg MAIN_TYPE storage_bus[STORAGE_SIZE];
  Reg MAIN_TYPE input_data[INPUT_DATA_SIZE];
  Reg MAIN_TYPE log_bus[LOG_AREA_SIZE];
  Reg MAIN_TYPE stack_arr[STACK_SIZE];
  
  // log pointer
  Reg int32 log_ptr, "log_ptr";
  
  PCOUNT pc;
  extern MAIN_TYPE KeccakAlg(int32 offs,int32 size);   

  MAIN_TYPE StopExec()
  {
    dbg_msg "@";
    return (MAIN_TYPE)0;
  }

  MAIN_TYPE GetExp(MAIN_TYPE a,MAIN_TYPE b)
  {
    USEGAS(STEPGAS5);
    int8 i;
    MAIN_TYPE res = 1;
    MAIN_TYPE mul_fact = a;

    for(i = 0; i < MAIN_TYPE_SIZE; i = i+1)
    {
       if(b[i] == 1)
         res = res * mul_fact;
       mul_fact = mul_fact * mul_fact;
    }
    return res;
  }
  // pop result from stack
  MAIN_TYPE Pop()
  {
    MAIN_TYPE ret;
    int32 sp_tmp = sp;
    sp = sp + 1;
    ret = stack_arr[sp_tmp];
    return ret;
  }
 // push result to stack
  void Push(MAIN_TYPE val)
  {
    stack_arr[sp] = val;
    sp = sp - 1;
  }

  // extend sign 
  MAIN_TYPE SignExtend(MAIN_TYPE a, MAIN_TYPE b)
  {
    int32 testBit;
    int32 end_bit;
    MAIN_TYPE number;
    MAIN_TYPE mask;
    USEGAS(STEPGAS3);

    if(a < 31) {
      testBit = (int32)(a*8) + 7;
      end_bit = testBit + 1;
      mask = ((MAIN_TYPE)1 << testBit) - 1;
      if (b[end_bit:testBit] == 1) // check if a bit 'b[testBit]' is set
        number = b | ~mask;
      else
        number = b & mask;
      return number;
    }
    return (MAIN_TYPE)0;
  }

  // extract byte from word
  MAIN_TYPE ByteFromWord(MAIN_TYPE a, MAIN_TYPE b)
  {
     USEGAS(STEPGAS2);
     int32 start_bit = (int32)(a*8);
     int32 end_bit = start_bit + 7;
     return b[end_bit:start_bit]; 
  }

  MAIN_TYPE GetModule(MAIN_TYPE a, MAIN_TYPE mod)
  {
    USEGAS(STEPGAS3);
    MAIN_TYPE div;
    if (mod == 0)
      return 0;
    else
    {
      div = a / mod;
      return a - (div * mod);
    }
  }

  MAIN_TYPE GetModuleAM(MAIN_TYPE a, MAIN_TYPE mod)
  {
    USEGAS(STEPGAS4);
    MAIN_TYPE div;
    if (mod == 0)
      return 0;
    else
    {
      div = a / mod;
      return a - (div * mod);
    }
  }

  MAIN_TYPE GetModuleS(MAIN_TYPE a, MAIN_TYPE mod)
  {
    USEGAS(STEPGAS3);
    MAIN_TYPE div;
    if (mod == 0)
      return 0;
    else
    {
      div = (signed)a / (signed)mod;
      return (signed)a - (signed)(div * mod);
    }// if(mod == 0) .. else
  }

  MAIN_TYPE StopOp()
  {
    USEGAS(STEPGAS0);
    dbg_msg "@";
    return (MAIN_TYPE)0;
  }

  MAIN_TYPE AddOp(MAIN_TYPE a, MAIN_TYPE b)
  {
    USEGAS(STEPGAS2);
    return a + b ;
  }

  MAIN_TYPE SubOp(MAIN_TYPE a, MAIN_TYPE b)
  {
    USEGAS(STEPGAS2);
    return a - b ;
  }

  MAIN_TYPE MulOp(MAIN_TYPE a, MAIN_TYPE b)
  {
    USEGAS(STEPGAS3);
    return a * b ;
  }

  MAIN_TYPE DivOp(MAIN_TYPE a, MAIN_TYPE b)
  {
    USEGAS(STEPGAS3);
    if (b == 0)
      return 0;
    else 
      return a / b ;
  }

  MAIN_TYPE LtOp(MAIN_TYPE a, MAIN_TYPE b)
  {
    USEGAS(STEPGAS2);
    return a < b;
  }

  MAIN_TYPE LtOpS(MAIN_TYPE a, MAIN_TYPE b)
  {
    USEGAS(STEPGAS2);
    return (signed)a < (signed)b;
  }

  MAIN_TYPE GtOp(MAIN_TYPE a, MAIN_TYPE b)
  {
    USEGAS(STEPGAS2);
    return a > b;
  }

  MAIN_TYPE GtOpS(MAIN_TYPE a, MAIN_TYPE b)
  {
    USEGAS(STEPGAS2);
    return (signed)a > (signed)b;
  }

  MAIN_TYPE EqOp(MAIN_TYPE a, MAIN_TYPE b)
  {
    USEGAS(STEPGAS2);
    return a == b;
  }

  MAIN_TYPE IsZeroOp(MAIN_TYPE a)
  {
    USEGAS(STEPGAS2);
    return a == 0;
  }

  MAIN_TYPE AndOp(MAIN_TYPE a, MAIN_TYPE b)
  {
    USEGAS(STEPGAS2);
    return a & b;
  }

  MAIN_TYPE OrOp(MAIN_TYPE a, MAIN_TYPE b)
  {
    USEGAS(STEPGAS2);
    return a | b;
  }

  MAIN_TYPE XorOp(MAIN_TYPE a, MAIN_TYPE b)
  {
    USEGAS(STEPGAS2);
    return a ^ b;
  }

  MAIN_TYPE NotOp(MAIN_TYPE a)
  {
    USEGAS(STEPGAS2);
    return ~a;
  }

  ArgList MAIN_TYPE ArithmOps(MAIN_TYPE a, MAIN_TYPE b, MAIN_TYPE c),
  { 
    // 0
    "STOP","ADD","MUL","SUB",
    // 4
    "DIV","MOD","SMOD","ADDMOD",
    // 8
    "MULMOD","EXP","SIGNEXTEND"
  },
  {
    // 0
    StopOp(), AddOp(a , b), MulOp(a , b), SubOp(a , b),
    // 4
    DivOp(a , b), GetModule(a , b), GetModuleS(a , b), GetModuleAM((a + b) , c),
    // 8
    GetModuleAM((a  * b) , c), GetExp(a , b), SignExtend(a , b)
  };
    
    
  ArgList MAIN_TYPE CompareLogOps(MAIN_TYPE a, MAIN_TYPE b),
  {
    // 
    "LT","GT","SLT","SGT",
    "EQ","ISZERO","AND","OR",
    "XOR","NOT","BYTE"
  },
  {
    LtOp(a , b), GtOp(a , b), LtOpS(a , b), GtOpS(a , b), 
    EqOp(a , b), IsZeroOp(a), AndOp(a , b), OrOp(a , b), 
    XorOp(a , b), NotOp(a), ByteFromWord(a , b)
  };   
    
    
  ArgList int32 MemOps,
  {
    "POP", "MLOAD", "MSTORE", "MSTORE8",
    "SLOAD", "SSTORE", "JUMP", "JUMPI",
    "PC", "MSIZE", "GAS", "JUMPDEST"
  };
   
   
  MAIN_TYPE CallValue()
  {
    USEGAS(STEPGAS1);
    return (MAIN_TYPE)0;
  }
  
  MAIN_TYPE CallDataCopy(MAIN_TYPE a, MAIN_TYPE b, MAIN_TYPE c)
  {
    USEGAS(STEPGAS2);
    return (MAIN_TYPE)0;
  }

  MAIN_TYPE CallDataSize()
  {
    USEGAS(STEPGAS1);
    return inp_data_size;
  }

  MAIN_TYPE CodeCopy(MAIN_TYPE a, MAIN_TYPE b, MAIN_TYPE c)
  {
    USEGAS(STEPGAS2);
    return (MAIN_TYPE)0;
  }

  MAIN_TYPE ExtCodeSize()
  {
    USEGAS(STEPGAS6);
    return ext_code_size;
  }

  MAIN_TYPE ExtCodeCopy(MAIN_TYPE a, MAIN_TYPE b, MAIN_TYPE c, MAIN_TYPE d)
  {
    USEGAS(STEPGAS6);
    // copy from prog bus to memory
    return (MAIN_TYPE)0;
  }

   MAIN_TYPE GetAddress()
   {
     EVM_ADDR_TYPE ca = cur_addr;
     USEGAS(STEPGAS1);
     return (MAIN_TYPE)ca;
   }

   // get balance of gived account
  MAIN_TYPE GetBalance(MAIN_TYPE a)
  {
    USEGAS(STEPGAS6);
    return (MAIN_TYPE)0;
  }  

   MAIN_TYPE GetOrigin()
   {
     EVM_ADDR_TYPE oa = origin_addr;
     USEGAS(STEPGAS1);
     return (MAIN_TYPE)oa;
   }

   MAIN_TYPE GetCaller()
   {
     EVM_ADDR_TYPE ca = caller_addr;
     USEGAS(STEPGAS1);
     return (MAIN_TYPE)ca;
   }

   MAIN_TYPE GetInputData()
   {
     USEGAS(STEPGAS2);
     int32 addr_val = (int32)Pop();
     MAIN_TYPE inp_data = input_data[addr_val];
     return inp_data;
   }

   MAIN_TYPE GetCodeSize()
   {
     USEGAS(STEPGAS1);
     return code_size;
   }

   MAIN_TYPE GetGasPrice()
   {
     EVM_BALANCE_TYPE gp = gas_price;
     USEGAS(STEPGAS1);
     return (MAIN_TYPE)gp;
   }

   // accounts data
  ArgList MAIN_TYPE AccountsData(),
  {
    "ADDRESS", "BALANCE", "ORIGIN", "CALLER",
    "CALLVALUE", "CALLDATALOAD", "CALLDATASIZE", "CALLDATACOPY",
    "CODESIZE", "CODECOPY", "GASPRICE", "EXTCODESIZE",
    "EXTCODECOPY"
  },
  {
    GetAddress(), GetBalance(Pop()), GetOrigin(), GetCaller(),
    CallValue(), GetInputData(), CallDataSize(), CallDataCopy(Pop(),Pop(),Pop()),
    GetCodeSize(), CodeCopy(Pop(),Pop(),Pop()), GetGasPrice(), ExtCodeSize(),
    ExtCodeCopy(Pop(),Pop(),Pop(),Pop())
  };
   
  // blockchain related data
  Var MAIN_TYPE CoinBase,"CoinBase";
  Var MAIN_TYPE TimeStamp, "TimeStamp";
  Var MAIN_TYPE Number, "Number";
  Var MAIN_TYPE Difficulty, "Difficulty";
  Var MAIN_TYPE GasLimit, "GasLimit";
  
  MAIN_TYPE BlockChainHash(MAIN_TYPE a)
  {
    USEGAS(STEPGAS6);
    CoinBase = 0x10; // ot baldi
    TimeStamp = 0x1000;
    Number = 0x1234543234;
    Difficulty = 0x420323;
    GasLimit = 0x1000;
    return (MAIN_TYPE)0;
  }

  MAIN_TYPE GetCoinBase()
  {
    USEGAS(STEPGAS1);
    return CoinBase;
  }

  MAIN_TYPE GetTimeStamp()
  {
    USEGAS(STEPGAS1);
    return TimeStamp;
  }

  MAIN_TYPE GetNumber()
  {
    USEGAS(STEPGAS1);
    return Number;
  }

  MAIN_TYPE GetDifficulty()
  {
    USEGAS(STEPGAS1);
    return Difficulty;
  }

  MAIN_TYPE GetGasLimit()
  {
    USEGAS(STEPGAS1);
    return GasLimit;
  }

  ArgList MAIN_TYPE BlockChain(),
  {
    "BLOCKHASH", "COINBASE", "TIMESTAMP", "NUMBER", "DIFFICULTY", "GASLIMIT"
  },
  {
    BlockChainHash(Pop()), GetCoinBase(), GetTimeStamp(), GetNumber(), GetDifficulty(), GetGasLimit()
  };
   
   
   // system operations
   MAIN_TYPE CreateAccount(MAIN_TYPE endowment, MAIN_TYPE initOff, MAIN_TYPE initSize)
   {
     USEGAS(CREATEGAS);
     MAIN_TYPE account;
     account = 0x123456;
     // TODO
     return account;

   }
   
   MAIN_TYPE MakeCall()
   {
     USEGAS(CALLGAS);
     MAIN_TYPE callGas = Pop();
     MAIN_TYPE address = Pop();
     MAIN_TYPE value = Pop();
     MAIN_TYPE inOff = Pop();
     MAIN_TYPE inSize = Pop();
     MAIN_TYPE outOff = Pop();
     MAIN_TYPE outSize = Pop();
     MAIN_TYPE call_res = 0;
     return call_res;
   }
   
   MAIN_TYPE MakeCallCode()
   {
     USEGAS(CALLGAS);
     MAIN_TYPE callGas = Pop();
     MAIN_TYPE address = Pop();
     MAIN_TYPE value = Pop();
     MAIN_TYPE inOff = Pop();
     MAIN_TYPE inSize = Pop();
     MAIN_TYPE outOff = Pop();
     MAIN_TYPE outSize = Pop();
     MAIN_TYPE call_res = 0;
     return call_res;
   }
   
   MAIN_TYPE Return()
   {
     USEGAS(STEPGAS0);
     MAIN_TYPE a = Pop();
     MAIN_TYPE b = Pop();
     StopExec();
     return (MAIN_TYPE)0;
   }
   
   MAIN_TYPE DelegateCall()
   {
     USEGAS(CALLGAS);
     MAIN_TYPE callGas = Pop();
     MAIN_TYPE address = Pop();
     MAIN_TYPE inOff = Pop();
     MAIN_TYPE inSize = Pop();
     MAIN_TYPE outOff = Pop();
     MAIN_TYPE outSize = Pop();
     MAIN_TYPE call_res = 0;
     return call_res;
   }
 
   ArgList MAIN_TYPE SystemOps,
   {
     "CREATE","CALL","CALLCODE","RETURN","DELEGATECALL"
   },
   {
     CreateAccount(Pop(),Pop(),Pop()),MakeCall(),MakeCallCode(),Return(),DelegateCall()
   };
   
   
   
   
  //  instruction set;
  ISET Main
  {
    INST "$syscall",(8,int4 syscall = SystemOps,int4 0xf)
    {
      MAIN_TYPE res = syscall();
      if(idx(syscall) != 0x3) // except return
        Push(res);
    }
    
    INST "STATICCALL",(8,int8 0xfa)
    {
      USEGAS(CALLGAS);
      MAIN_TYPE callGas = Pop();
      MAIN_TYPE address = Pop();
      MAIN_TYPE value = 0;
      MAIN_TYPE inOff = Pop();
      MAIN_TYPE inSize = Pop();
      MAIN_TYPE outOff = Pop();
      MAIN_TYPE outSize = Pop();
    }

    INST "REVERT", (8,int8 0xfd)
    {
       USEGAS(STEPGAS0);
       MAIN_TYPE a = Pop();
       MAIN_TYPE b = Pop();
       StopExec();
    }
    INST "SUICIDE",(8,int8 0xff)
    {
      USEGAS(STEPGAS0);
      MAIN_TYPE a = Pop();
      StopExec();      
    }
    
    INST "$gas_opcode",(8,int4 gas_opcode = BlockChain,int4 0x4)
    {
      MAIN_TYPE res = gas_opcode;
      Push(res);
    }
    
    INST "$opcode",(8,int4 opcode = AccountsData,int4 0x3)
    {
      MAIN_TYPE res = opcode;
      if( (idx(opcode)!=0x7)  && (idx(opcode)!=9) && (idx(opcode)!=0xc))
        Push(res);
    }
    
        
    INST "PUSH$count", (8,int5 count,int3 0b011)
    {
      USEGAS(STEPGAS2);
      int32 i;
      MAIN_TYPE a = 0;
      MAIN_TYPE tmp;
      is_pc_within_inst = 1;
      int32 cnt = count + 1;
      for(i = 0; i < cnt; i=i+1)
      {
        tmp = prog_bus[pc + i + 1] & 0xFF;
        a = a | (tmp << (8*i));
      }
      Push(a);
      pc = pc + cnt + 1;
    }
    
    INST "DUP$count", (8,int4 count,int4 0x8)
    {
      USEGAS(STEPGAS2);
      MAIN_TYPE a;
      a = stack_arr[sp  + (count + 1)];
      Push(a);
    }
    
    
    INST "SWAP$count", (8,int4 count,int4 0x9)
    {
      USEGAS(STEPGAS2);
      MAIN_TYPE first_el = stack_arr[sp + 1];
      stack_arr[sp + 1] = stack_arr[sp + count + 2];
      stack_arr[sp + count + 2] = first_el;
    }
    
    INST "LOG$count", (8, int3 count,int1 0,int4 0xa)
    {
      USEGAS(LOGGAS + count * LOGTOPICGAS);
      int32 i;
      MAIN_TYPE l1_data = Pop();
      MAIN_TYPE l2_data = Pop();
      int32 m_ptr = (int32)l1_data;
      int32 m_size = (int32)l2_data;
      // write log data
      for(i = 0; i < count; i = i + 1)
      {
        log_bus[log_ptr + 2 + count] = Pop();
      }
            
      log_ptr = count + 2;
    } 
    
    INST "$opcode", (8,int4 opcode = MemOps,int4 0x5)
    {
      int32 i;
      int32 dec_cnt;
      int32 addr_val;
      MAIN_TYPE data_val;
      MAIN_TYPE pc_val;
      MAIN_TYPE data_tmp;
      
      if(opcode < 8) 
        addr_val = (int32)Pop();
      switch((int32)opcode)
      {
        case 0: // POP
          USEGAS(STEPGAS1);
          Pop(); 
          break;

        case 1: // MLOAD
          USEGAS(STEPGAS2);
          data_val = 0;
          for(i = 0; i < 32; i=i+1)
          {
            data_val = (data_val << 8) | (MAIN_TYPE)data_bus[addr_val];
            addr_val = addr_val + 1;
          }
          Push(data_val);
          break;

        case 2: // MSTORE
          USEGAS(STEPGAS2);
          data_val = Pop();
          for(i = 31; i > 0; i=i-1)
          {
            data_tmp = data_val >> (8*i);
            data_bus[addr_val] = (int8)(data_tmp);
            addr_val = addr_val + 1;
          }
          break;

        case 3: // MSTORE8
          USEGAS(STEPGAS2);
          data_val = Pop();
          data_bus[addr_val] = (int8)(data_val);
          break;

        case 4: // SLOAD
          USEGAS(SLOADGAS);
          data_val = storage_bus[addr_val]; 
          Push(data_val);
          break;

        case 5: // SSTORE
          USEGAS(STEPGAS0);
          data_val = Pop();
          storage_bus[addr_val] = data_val;
          break;

        case 6: // JUMP 
          USEGAS(STEPGAS4);
          pc = addr_val;
          is_pc_within_inst = 1;
          break;

        case 7: // JUMPI
          USEGAS(STEPGAS5);
          if(Pop()!=0) // get condition
          {
            pc = (int32)addr_val; // set new pc
            is_pc_within_inst = 1;
          }
          break;

        case 8: // PC
         USEGAS(STEPGAS1);
         data_val = (MAIN_TYPE)pc;
         Push(data_val);
         break;

        case 9: // MSIZE
         USEGAS(STEPGAS1);
         data_val  = (MAIN_TYPE)mem_size;
         Push(data_val);
         break;

        case 10: // GAS
         USEGAS(STEPGAS1);
         Push((MAIN_TYPE)gas_available);
         break;

        case 11: // JUMPDEST
         USEGAS(JUMPDESTGAS);
         break; // do nothing
      }// end of switch

    } // end of instruction

    INST "$opcode",(8,int4 opcode = ArithmOps,int4 0x0)
    {
      MAIN_TYPE a;
      MAIN_TYPE b;
      MAIN_TYPE c;
      MAIN_TYPE res;
      // get args;
      a = Pop();
      b = Pop();
      c = ( (idx(opcode)== 7) && (idx(opcode) == 8) ) ? Pop() : 0;
      // compute
      res = opcode(a,b,c);
      // push to stack
      Push(res);
    }
     
    INST "$opcode", (8,int4 opcode = CompareLogOps, int4 0x1)
    {
      MAIN_TYPE a;
      MAIN_TYPE b;
      MAIN_TYPE c;
      MAIN_TYPE res;
      // get args;
      a = Pop();
      b = ((idx(opcode) == 5) || (idx(opcode) == 9)) ? 0: Pop();
      // compute
      res = opcode(a,b);
      // push to stack
      Push(res);
    }

    INST "SHA3", (8,int8 0x20)
    {
      USEGAS(SHA3GAS);
       // compute Keccak-256 hash
      MAIN_TYPE a;
      MAIN_TYPE b;
      MAIN_TYPE res;
      a = Pop();
      b = Pop();
      res = KeccakAlg((int32)a,(int32)b);
      Push(res);
    }

  }// end of ISET

   RESET
   {
     pc = 0;
     sp = STACK_SIZE - 1;
     log_ptr = 0;
   }

  Operate
  {
    int8 code = prog_bus[pc];
    // reset flags
    is_pc_within_inst = 0;
    // decode and execute
    Main.decode(code);
    // increment pc flag if need
    if(is_pc_within_inst == 0)
      pc = pc + 1;
  }