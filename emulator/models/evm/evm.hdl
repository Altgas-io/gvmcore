
#define MAIN_TYPE int256
#define MAIN_TYPE_SIZE 256
#define EVM_ADDR_TYPE int160
#define EVM_BALANCE_TYPE int32

#define DATA_SIZE 1024
#define STORAGE_SIZE 256
#define LOG_AREA_SIZE 1024
#define INPUT_DATA_SIZE 1024

Device EVM
{
  //stack pointer
  Var int32 sp, "sp";
  // program couter
  Reg int32 pc,"pc";
  Var int1  is_pc_within_inst;
  
  // account specific regs
  Reg EVM_ADDR_TYPE     cur_addr,"cur_addr";
  Reg EVM_ADDR_TYPE     caller_addr, "caller_addr";  
  Reg EVM_ADDR_TYPE     origin_addr, "origin_addr";
 
  Reg EVM_BALANCE_TYPE  gas_price, "gas_price";  
  Reg EVM_BALANCE_TYPE  gas_available, "gas_available";
  
  Reg MAIN_TYPE  code_size,"code_size";
  Reg MAIN_TYPE  ext_code_size,"ext_code_size";
  Reg MAIN_TYPE  inp_data_size,"inp_data_size"; 
  // size of active memory 
  Reg int32 mem_size; // active memory size (filled outside of simulation)
  // current block
   
   
  
  MemSpace prog_bus, 32, 32;
  // memory access  (256 size data bus)
  /*MemSpace data_bus, 32, MAIN_TYPE_SIZE;
  MemSpace storage_bus, 32, MAIN_TYPE_SIZE;
  MemSpace log_bus, 32, MAIN_TYPE_SIZE;
  MemSpace input_data, 32,MAIN_TYPE_SIZE;
  */
  Reg MAIN_TYPE data_bus[DATA_SIZE];
  Reg MAIN_TYPE storage_bus[STORAGE_SIZE];
  Reg MAIN_TYPE input_data[INPUT_DATA_SIZE];
  Reg MAIN_TYPE log_bus[LOG_AREA_SIZE];
  
  // log pointer
  Reg int32 log_ptr, "log_ptr";
  
  PCOUNT pc;
  
  
  MAIN_TYPE GetExp(MAIN_TYPE a,MAIN_TYPE b)
  {
    int8 i;
    MAIN_TYPE res = 1;
    MAIN_TYPE mul_fact = a;

    for(i = 0; i < MAIN_TYPE_SIZE; i = i+1)
    {
       if(b[i] == 1)
         res = res * mul_fact;
       mul_fact = mul_fact * mul_fact;
    }
    return res;
  }
  // pop result from stack
  MAIN_TYPE Pop()
  {
    MAIN_TYPE ret;
    int32 sp_tmp = sp;
    sp = sp + 1;
    ret = data_bus[sp_tmp];
    return ret;
  }
 // push result to stack
  void Push(MAIN_TYPE val)
  {
    data_bus[sp] = val; 
    sp = sp - 1;
  }
  
  // extend sign 
  MAIN_TYPE SignExtend(MAIN_TYPE a, MAIN_TYPE b)
  {
    // TODO
    return 0;
  }
  
  // extract byte from word
  MAIN_TYPE ByteFromWord(MAIN_TYPE a, MAIN_TYPE b)
  {
     int32 start_bit = 0;//((int32)a*8);
     int32 end_bit = start_bit + 7;
     if( a > 0)
       return b[end_bit:start_bit]; 
    else
       return 0;
  }
  
  MAIN_TYPE GetModule(MAIN_TYPE a, MAIN_TYPE mod)
  {
    MAIN_TYPE div;
    if (mod == 0)
      return 0;
    else
    {
      div = a / mod;
      return a - (div * mod);
    }
  }
  
  MAIN_TYPE GetModuleS(MAIN_TYPE a, MAIN_TYPE mod)
  {
    MAIN_TYPE div;
    if (mod == 0)
      return 0;
    else
    {
      div = (signed)a / (signed)mod;
      return (signed)a - (signed)(div * mod);
    }// if(mod == 0) .. else
  }
  
  MAIN_TYPE StopExec()
  {
    dbg_msg "@";
    return (MAIN_TYPE)0;
  }

  MAIN_TYPE DivOp(MAIN_TYPE a,MAIN_TYPE b)
  {
    if (b == 0)
      return 0;
    else 
      return a / b ;
  }
  
    
  ArgList MAIN_TYPE ArithmOps(MAIN_TYPE a, MAIN_TYPE b, MAIN_TYPE c),
  { 
    // 0
    "STOP","ADD","MUL","SUB",
    // 4
    "DIV","MOD","SMOD","ADDMOD",
    // 8
    "MULMOD","EXP","SIGNEXTEND"
  },
  {
    // 0
    StopExec(), a + b, a * b, a - b,
    // 4
    DivOp(a , b),  GetModule(a , b),  GetModuleS(a , b),  GetModule((a + b) , c),
    // 8
    GetModule((a  * b) , c), GetExp(a,b), SignExtend(a,b)
  };
    
    
  ArgList MAIN_TYPE CompareLogOps(MAIN_TYPE a, MAIN_TYPE b),
  {
    // 
    "LT","GT","SLT","SGT",
    "EQ","IZSERO","AND","OR",
    "XOR","NOT","BYTE"
  },
  {
    a < b, a > b, (signed)a < (signed)b, (signed)a > (signed)b, 
    a == b, a == 0, a & b, a | b, 
    a ^ b , ~a, ByteFromWord(a,b)
  };   
    
    
  ArgList int32 MemOps,
  {
    "POP", "MLOAD", "MSTORE", "MSTORE8",
    "SLOAD","SSTORE", "JUMP","JUMPI", 
    "PC", "MSIZE","GAS", "JUMPDEST"
  };
   
   
  MAIN_TYPE CallValue()
  {
    return (MAIN_TYPE)0;
  }
  
  MAIN_TYPE CallDataCopy(MAIN_TYPE a,MAIN_TYPE b,MAIN_TYPE c)
  {
    return (MAIN_TYPE)0;
  }
  
  MAIN_TYPE CodeCopy(MAIN_TYPE a,MAIN_TYPE b,MAIN_TYPE c)
  {
    /
    return (MAIN_TYPE)0;
  }
   
  MAIN_TYPE ExtCodeCopy(MAIN_TYPE a,MAIN_TYPE b,MAIN_TYPE c,MAIN_TYPE d)
  {
    // copy from prog bus to memory
    return (MAIN_TYPE)0;
  }
   
   // get balance of gived account
  MAIN_TYPE GetBalance(MAIN_TYPE a)
  {
    return (MAIN_TYPE)0;
  }  
   
   MAIN_TYPE GetInputData()
   {
     int32 addr_val = 0;/* (int32)*/Pop();
     MAIN_TYPE inp_data = input_data[addr_val];
     return inp_data;
   }
   // accounts dataa
  ArgList MAIN_TYPE AccountsData(),
  {
    "ADDRESS", "BALANCE","ORIGIN","CALLER",
    "CALLVALUE","CALLDATALOAD","CALLDATASIZE","CALLDATACOPY",
    "CODESIZE","CODECOPY","GASPRICE", "EXTCODESIZE",
    "EXTCODECOPY"    
  },
  {
    cur_addr,GetBalance(Pop()),origin_addr,caller_addr,
    CallValue(),GetInputData(), inp_data_size,CallDataCopy(Pop(),Pop(),Pop()),
    code_size, CodeCopy(Pop(),Pop(),Pop()),gas_price,ext_code_size, 
    ExtCodeCopy(Pop(),Pop(),Pop(),Pop())
  };
   
  //  instruction set;
  ISET Main
  {
    
    INST "$opcode",(8,int4 0x3,int4 opcode = AccountsData)
    {
      MAIN_TYPE res = opcode;
      if( (idx(opcode)=0x7)  && (idx(opcode)!=9) && (idx(opcode)!=0xc))
        Push(res);      
    }
    
        
    INST "PUSH$count", (8,int5 count,int3 0b011)
    {
      int32 i;
      MAIN_TYPE a = 0;
      MAIN_TYPE tmp;
      is_pc_within_inst = 1;
      for(i = 0; i < count; i=i+1)
      {
        tmp = prog_bus[pc + i + 1] & 0xFF;
        a = a | (tmp << (8*i));
      }
      Push(a);
      pc = pc + 1 + count;
    }
    
    INST "DUP$count", (8,int4 count,int4 0x8)
    {
      MAIN_TYPE a;
      a = data_bus[sp  + (count + 1)];
      Push(a);
    }
    
    
    INST "SWAP$count", (8,int4 count,int4 0x9)
    {
      MAIN_TYPE first_el = data_bus[sp + 1];
      data_bus[sp + 1] = data_bus[sp + count + 2];
      data_bus[sp + count + 2] = first_el;
    }
    
    INST "LOG$count", (8, int3 count,int4 0xa, int1 0)
    {
      int32 i;
      MAIN_TYPE l1_data = Pop();
      MAIN_TYPE l2_data = Pop();
      log_bus[log_ptr] = l1_data;
      log_bus[log_ptr + 1] = l2_data;

      // write log data
      for(i = 0; i < count; i = i + 1)
      {
        log_bus[log_ptr + 2 + count] = Pop();
      }
      log_ptr = count + 2;
    }
    
    
    INST "$opcode", (8,int4 opcode = MemOps,int4 0xb0101)
    {
      int32 addr_val;
      MAIN_TYPE data_val;
      MAIN_TYPE pc_val;
      
      if(opcode < 8) 
        addr_val = 0;/*(int32)*/Pop();
      switch((int32)opcode)
      {
        case 0: 
          Pop(); 
          break;
        
        case 1: // MLOAD 
          data_val = data_bus[addr_val];
          Push(data_val);
          break;
          
        case 2: // MSTORE
          data_val = Pop();
          data_bus[addr_val] = data_val;
          break;
        
        case 3: // MSTORE8 
          data_val = data_bus[addr_val];
          data_val = Pop() & 0xFF | (data_val & 0xFFFFFF00);
          data_bus[addr_val] = data_val;
          break;
          
        case 4: // SLOAD
          data_val = storage_bus[addr_val]; 
          Push(data_val);
          break;
          
        case 5: // sstore
          data_val = Pop();
          storage_bus[addr_val] = data_val;
          break;

        case 6: // JUMP 
          pc = addr_val;
          is_pc_within_inst = 1;
          break;
          
        case 7: // JUMPI
          if(Pop()!=0) // get condition
          {
            pc = (int32)addr_val; // set new pc
            is_pc_within_inst = 1;
          }
          break;
          
         case 8: // PC
           data_val = (MAIN_TYPE)pc; 
           Push(data_val); 
           break;
           
         case 9: // MSIZE 
           data_val  = (MAIN_TYPE)mem_size;
           Push(data_val);
           break;
           
         case 10: // GAS
           Push((MAIN_TYPE)gas_available);
           break;
           
         case 11: // JUMPDEST
           break; // do nothing
      }// end of switch
      
    } // end of instruction
    
    INST "$opcode",(8,int4 opcode = ArithmOps,int4 0x0)
    {
      MAIN_TYPE a;
      MAIN_TYPE b;
      MAIN_TYPE c;
      MAIN_TYPE res;
      // get args;
      a = Pop();
      b = Pop();
      c = ( (idx(opcode)== 7) && (idx(opcode) == 8) ) ? Pop() : 0;
      // compute
      res = opcode(a,b,c);
      // push to stack
      Push(res);   
    }
     
     INST "$opcode", (8,int4 opcode = CompareLogOps, int4 0x1)
     {
        MAIN_TYPE a;
        MAIN_TYPE b;
        MAIN_TYPE c;
        MAIN_TYPE res;
        // get args;
        a = Pop();
        b = ((idx(opcode) == 5) || (idx(opcode) == 9)) ? 0: Pop();
        // compute
        res = opcode(a,b);
        // push to stack
        Push(res);
     }
 
     INST "SHA3", (8,int8 0x20)
     {
       // compute Keccak-256 hash
     }
      
      
              
  }// end of ISET
   
   RESET
   {
     pc = 0;
     sp = DATA_SIZE;
   }
 
  Operate
  {   
    int8 code = prog_bus[pc];
    // reset flags
    is_pc_within_inst = 0; 
    // decode and execute 
    Main.decode(code);
    // increment pc flag if need
    if(is_pc_within_inst == 0 )
      pc = pc + 1;      
  }
  
